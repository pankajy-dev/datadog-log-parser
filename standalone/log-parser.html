<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Log Parser Utility - Standalone</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='90'>üìä</text></svg>">
    <style>
/* CSS - Embedded from style.css */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

/* Variables - CloudBees.io Dark Theme */
:root {
    --primary-color: #3b9aee;
    --primary-hover: #2b8ae0;
    --secondary-color: #6b7280;
    --success-color: #10b981;
    --error-color: #ef4444;
    --warning-color: #f59e0b;
    --accent-cyan: #00d4ff;
    --bg-primary: #2b2d31;
    --bg-secondary: #1e1f22;
    --bg-tertiary: #36383d;
    --bg-hover: #3a3d42;
    --text-primary: #f1f5f9;
    --text-secondary: #b4b8bc;
    --text-muted: #82868b;
    --border-color: #3a3d42;
    --border-radius: 6px;
    --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.3);
    --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.4);
    --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
    --transition: all 0.2s ease;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    background-color: var(--bg-secondary);
    color: var(--text-primary);
    line-height: 1.6;
    min-height: 100vh;
    background-image: radial-gradient(circle at 20% 20%, rgba(59, 154, 238, 0.05) 0%, transparent 50%);
}

.container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 20px;
}

.header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 30px 0;
    margin-bottom: 30px;
    border-bottom: 1px solid var(--border-color);
}

.header-content h1 {
    font-size: 2rem;
    font-weight: 700;
    margin-bottom: 5px;
    display: flex;
    align-items: center;
    gap: 10px;
}

.header-content h1 .title-text {
    background: linear-gradient(135deg, var(--primary-color), var(--accent-cyan));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.header-content h1 .title-icon {
    font-size: 2rem;
}

.subtitle {
    color: var(--text-secondary);
    font-size: 0.95rem;
}

.header-actions {
    display: flex;
    gap: 10px;
}

.main-content {
    display: grid;
    grid-template-columns: 450px 1fr;
    gap: 20px;
    align-items: start;
}

.left-panel {
    display: flex;
    flex-direction: column;
    gap: 20px;
    position: sticky;
    top: 20px;
}

.right-panel {
    display: flex;
    flex-direction: column;
    gap: 20px;
    min-height: 400px;
}

.section {
    background: var(--bg-primary);
    border-radius: var(--border-radius);
    padding: 25px;
    box-shadow: var(--shadow-md);
    border: 1px solid var(--border-color);
    transition: var(--transition);
}

.section:hover {
    border-color: rgba(59, 154, 238, 0.3);
}

.section h2 {
    font-size: 1.25rem;
    font-weight: 600;
    margin-bottom: 20px;
    display: flex;
    align-items: center;
    gap: 8px;
}

.left-panel .section {
    padding: 20px;
}

.left-panel .section:has(#parse-btn) {
    padding: 15px 20px;
}

.left-panel .section h2 {
    font-size: 1.1rem;
    margin-bottom: 15px;
}

.right-panel .section {
    padding: 20px;
}

.right-panel #results-section {
    min-height: 500px;
}

.tabs {
    display: flex;
    gap: 10px;
    margin-bottom: 20px;
    border-bottom: 2px solid var(--border-color);
}

.tab {
    padding: 10px 20px;
    background: none;
    border: none;
    cursor: pointer;
    color: var(--text-secondary);
    font-size: 0.95rem;
    font-weight: 500;
    transition: var(--transition);
    border-bottom: 3px solid transparent;
    margin-bottom: -2px;
}

.tab:hover {
    color: var(--text-primary);
}

.tab.active {
    color: var(--primary-color);
    border-bottom-color: var(--primary-color);
}

.tab-content {
    display: none;
}

.tab-content.active {
    display: block;
}

.upload-area {
    border: 2px dashed var(--border-color);
    border-radius: var(--border-radius);
    padding: 30px 20px;
    text-align: center;
    cursor: pointer;
    transition: var(--transition);
    background: var(--bg-secondary);
}

.upload-area:hover {
    border-color: var(--primary-color);
    background: var(--bg-tertiary);
    box-shadow: 0 0 20px rgba(59, 154, 238, 0.1);
}

.upload-area.dragover {
    border-color: var(--primary-color);
    background: rgba(59, 154, 238, 0.1);
    box-shadow: 0 0 30px rgba(59, 154, 238, 0.2);
}

.upload-icon {
    font-size: 3rem;
    margin-bottom: 10px;
}

.upload-text {
    font-size: 1rem;
    color: var(--text-primary);
    margin-bottom: 5px;
}

.upload-hint {
    font-size: 0.85rem;
    color: var(--text-secondary);
}

.link {
    color: var(--primary-color);
    cursor: pointer;
    text-decoration: underline;
}

.link:hover {
    color: var(--primary-hover);
}

.form-group {
    margin-top: 15px;
}

.form-group label {
    display: block;
    font-weight: 500;
    margin-bottom: 8px;
    color: var(--text-primary);
}

.form-group input[type="text"] {
    width: 100%;
    padding: 10px 15px;
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    font-size: 0.95rem;
    transition: var(--transition);
    background: var(--bg-primary);
    color: var(--text-primary);
}

.form-group input[type="text"]:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

textarea {
    width: 100%;
    min-height: 150px;
    padding: 12px;
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
    font-size: 0.85rem;
    resize: vertical;
    transition: var(--transition);
    background: var(--bg-primary);
    color: var(--text-primary);
}

textarea:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

.options-grid {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.option-item {
    padding: 12px;
    background: var(--bg-secondary);
    border-radius: var(--border-radius);
    border: 1px solid var(--border-color);
}

.checkbox-label {
    display: flex;
    align-items: center;
    gap: 10px;
    cursor: pointer;
    font-weight: 500;
    margin-bottom: 5px;
}

.checkbox-label input[type="checkbox"] {
    width: 18px;
    height: 18px;
    cursor: pointer;
    accent-color: var(--primary-color);
}

.option-description {
    font-size: 0.8rem;
    color: var(--text-secondary);
    margin-top: 5px;
    line-height: 1.3;
}

.slider-container {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-top: 8px;
}

input[type="range"] {
    flex: 1;
    height: 6px;
    border-radius: 3px;
    background: var(--border-color);
    outline: none;
    accent-color: var(--primary-color);
}

#keep-chars-value {
    font-weight: 600;
    color: var(--primary-color);
    min-width: 20px;
    text-align: center;
}

.btn-primary,
.btn-secondary,
.btn-icon {
    padding: 12px 24px;
    border: none;
    border-radius: var(--border-radius);
    font-size: 1rem;
    font-weight: 500;
    cursor: pointer;
    transition: var(--transition);
    display: inline-flex;
    align-items: center;
    gap: 8px;
}

.btn-primary {
    background: linear-gradient(135deg, var(--primary-color), var(--accent-cyan));
    color: white;
    width: 100%;
    justify-content: center;
    font-size: 1.1rem;
    padding: 15px;
    box-shadow: 0 4px 12px rgba(59, 154, 238, 0.3);
}

.btn-primary:hover {
    background: var(--primary-hover);
    transform: translateY(-1px);
    box-shadow: var(--shadow-md);
}

.btn-primary:active {
    transform: translateY(0);
}

.btn-primary:disabled {
    background: var(--secondary-color);
    cursor: not-allowed;
    opacity: 0.6;
}

.btn-secondary {
    background: var(--bg-secondary);
    color: var(--text-primary);
    border: 1px solid var(--border-color);
}

.btn-secondary:hover {
    background: var(--bg-tertiary);
}

.btn-icon {
    padding: 8px 12px;
    background: var(--bg-secondary);
    color: var(--text-primary);
    border: 1px solid var(--border-color);
    font-size: 1.2rem;
}

.btn-icon:hover {
    background: var(--bg-tertiary);
}

.btn-with-text {
    padding: 8px 16px;
    background: var(--bg-secondary);
    color: var(--text-primary);
    border: 1px solid var(--border-color);
    font-size: 0.95rem;
    border-radius: var(--border-radius);
    cursor: pointer;
    transition: var(--transition);
    display: inline-flex;
    align-items: center;
    gap: 6px;
    font-weight: 500;
}

.btn-with-text:hover {
    background: var(--bg-tertiary);
    border-color: var(--primary-color);
}

.btn-sm {
    padding: 5px 12px;
    font-size: 0.8rem;
}

.btn-delete:hover {
    background: rgba(239, 68, 68, 0.1);
    border-color: var(--error-color);
    color: var(--error-color);
}

.progress-bar {
    width: 100%;
    height: 4px;
    background: var(--border-color);
    border-radius: 2px;
    overflow: hidden;
    margin: 10px 0 0 0;
}

.progress-fill {
    height: 100%;
    background: var(--primary-color);
    width: 0%;
    animation: progress 2s ease-in-out infinite;
}

@keyframes progress {
    0% {
        width: 0%;
    }
    50% {
        width: 70%;
    }
    100% {
        width: 100%;
    }
}

.results-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    flex-wrap: wrap;
    gap: 15px;
}

.results-count {
    color: var(--text-secondary);
    font-size: 0.95rem;
}

.results-actions {
    display: flex;
    gap: 10px;
    align-items: center;
    flex-wrap: wrap;
}

.format-select {
    padding: 8px 12px;
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    background: var(--bg-secondary);
    color: var(--text-primary);
    font-size: 0.9rem;
    cursor: pointer;
}

.results-container {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    padding: 20px;
    max-height: 70vh;
    overflow: auto;
}

#results-output {
    font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
    font-size: 0.85rem;
    line-height: 1.5;
    white-space: pre-wrap;
    word-wrap: break-word;
    color: var(--text-primary);
}

#results-output .key { color: #3b9aee; }
#results-output .string { color: #98c379; }
#results-output .number { color: #d19a66; }
#results-output .boolean { color: #c678dd; }
#results-output .null { color: #82868b; }

.error-section {
    background: rgba(239, 68, 68, 0.1);
    border: 1px solid rgba(239, 68, 68, 0.3);
    border-radius: var(--border-radius);
    padding: 15px;
    margin-bottom: 20px;
}

.error-content {
    display: flex;
    align-items: start;
    gap: 15px;
}

.error-icon {
    font-size: 1.5rem;
    flex-shrink: 0;
}

.error-message {
    flex: 1;
}

.error-message strong {
    color: var(--error-color);
    display: block;
    margin-bottom: 5px;
}

.error-message p {
    color: var(--text-secondary);
    font-size: 0.9rem;
}

.right-panel-placeholder {
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 400px;
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    color: var(--text-muted);
    font-size: 1rem;
    text-align: center;
    padding: 40px;
}

.right-panel-placeholder.hidden {
    display: none;
}

.collapsible-section {
    padding: 0;
    overflow: hidden;
}

.collapsible-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px;
    cursor: pointer;
    transition: var(--transition);
    user-select: none;
}

.collapsible-header:hover {
    background: var(--bg-hover);
}

.collapsible-header h2 {
    margin: 0;
    font-size: 1.1rem;
}

.collapsible-hint {
    font-size: 0.75rem;
    color: var(--text-muted);
    margin: 3px 0 0 0;
}

.collapse-icon {
    font-size: 0.9rem;
    transition: transform 0.3s ease;
    color: var(--text-secondary);
}

.collapse-icon.expanded {
    transform: rotate(-180deg);
}

.collapsible-content {
    padding: 0 20px 20px 20px;
    animation: slideDown 0.3s ease;
}

@keyframes slideDown {
    from {
        opacity: 0;
        max-height: 0;
    }
    to {
        opacity: 1;
        max-height: 1000px;
    }
}

.history-sidebar {
    position: fixed;
    top: 0;
    right: -450px;
    width: 450px;
    height: 100vh;
    background: var(--bg-primary);
    box-shadow: -4px 0 20px rgba(0, 0, 0, 0.15);
    transition: right 0.3s ease;
    z-index: 1001;
    display: flex;
    flex-direction: column;
    border-left: 1px solid var(--border-color);
}

.history-sidebar.open {
    right: 0;
}

.history-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px;
    border-bottom: 1px solid var(--border-color);
    background: var(--bg-secondary);
}

.history-header h2 {
    margin: 0;
    font-size: 1.25rem;
}

.history-controls {
    padding: 15px;
    border-bottom: 1px solid var(--border-color);
    background: var(--bg-secondary);
}

.history-search {
    width: 100%;
    padding: 10px 15px;
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    font-size: 0.9rem;
    background: var(--bg-primary);
    color: var(--text-primary);
    margin-bottom: 10px;
}

.history-search:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

.history-filter-buttons {
    display: flex;
    gap: 8px;
    margin-bottom: 10px;
}

.filter-btn {
    flex: 1;
    padding: 8px 12px;
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    background: var(--bg-primary);
    color: var(--text-secondary);
    font-size: 0.9rem;
    font-weight: 500;
    cursor: pointer;
    transition: var(--transition);
}

.filter-btn:hover {
    background: var(--bg-tertiary);
    color: var(--text-primary);
}

.filter-btn.active {
    background: var(--primary-color);
    color: white;
    border-color: var(--primary-color);
}

.history-list {
    flex: 1;
    overflow-y: auto;
    padding: 15px;
}

.history-entry {
    display: flex;
    gap: 12px;
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    padding: 12px;
    margin-bottom: 10px;
    transition: var(--transition);
    position: relative;
    overflow: hidden;
}

.history-entry:hover {
    border-color: var(--primary-color);
    box-shadow: var(--shadow-sm);
    background: var(--bg-hover);
}

.history-entry.starred {
    border-left: 3px solid var(--warning-color);
    background: linear-gradient(to right, rgba(245, 158, 11, 0.08), var(--bg-secondary));
}

.history-entry-number {
    display: flex;
    align-items: flex-start;
    justify-content: center;
    min-width: 36px;
    height: 36px;
    padding-top: 8px;
    font-weight: 700;
    font-size: 0.9rem;
    color: var(--primary-color);
    background: rgba(59, 154, 238, 0.1);
    border-radius: 6px;
    flex-shrink: 0;
}

.history-entry-content {
    flex: 1;
    min-width: 0;
}

.history-entry-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
    margin-bottom: 8px;
}

.history-header-left {
    display: flex;
    align-items: center;
    gap: 8px;
    flex: 1;
    min-width: 0;
}

.history-source-name {
    font-weight: 600;
    color: var(--text-primary);
    font-size: 0.95rem;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.source-type-badge {
    padding: 3px 8px;
    border-radius: 4px;
    font-size: 0.7rem;
    font-weight: 500;
    white-space: nowrap;
    flex-shrink: 0;
}

.source-type-badge.csv {
    background: rgba(59, 154, 238, 0.15);
    color: var(--primary-color);
}

.source-type-badge.text {
    background: rgba(147, 51, 234, 0.15);
    color: #a78bfa;
}

.star-button {
    padding: 4px;
    background: none;
    border: none;
    font-size: 1.1rem;
    cursor: pointer;
    color: var(--warning-color);
    transition: var(--transition);
    flex-shrink: 0;
}

.star-button:hover {
    transform: scale(1.15);
}

.history-entry-meta {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 10px;
    font-size: 0.8rem;
    color: var(--text-secondary);
}

.history-entry-count,
.history-timestamp {
    display: flex;
    align-items: center;
    gap: 4px;
}

.history-entry-actions {
    display: flex;
    gap: 6px;
}

.history-empty {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 40px 20px;
    text-align: center;
}

.empty-icon {
    font-size: 4rem;
    margin-bottom: 15px;
    opacity: 0.5;
}

.history-empty p {
    color: var(--text-secondary);
    margin-bottom: 5px;
}

.empty-hint {
    font-size: 0.85rem;
    color: var(--text-muted);
}

.footer {
    text-align: center;
    padding: 30px 0;
    color: var(--text-secondary);
    font-size: 0.9rem;
}

.footer a {
    color: var(--primary-color);
    text-decoration: none;
}

.footer a:hover {
    text-decoration: underline;
}

@media (max-width: 1024px) {
    .main-content {
        grid-template-columns: 1fr;
    }

    .left-panel {
        position: static;
    }

    .right-panel {
        min-height: auto;
    }
}

@media (max-width: 768px) {
    .container {
        padding: 15px;
    }

    .header {
        flex-direction: column;
        align-items: flex-start;
        gap: 15px;
    }

    .header-content h1 {
        font-size: 1.5rem;
    }

    .results-header {
        flex-direction: column;
        align-items: flex-start;
    }

    .tabs {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
    }

    .history-sidebar {
        width: 100%;
        right: -100%;
    }

    .history-sidebar.open {
        right: 0;
    }
}

@keyframes fadeIn {
    from {
        opacity: 0;
        transform: translateY(-10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.fade-in {
    animation: fadeIn 0.3s ease;
}
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header class="header">
            <div class="header-content">
                <h1><span class="title-icon">üìä</span><span class="title-text">Log Parser Utility</span></h1>
                <p class="subtitle">Parse logs from Datadog, CSV files, and more ‚Ä¢ Standalone Version</p>
            </div>
            <div class="header-actions">
                <button class="btn-with-text" onclick="toggleHistory(event)">üìú History</button>
                <button class="btn-icon" onclick="showHelp()" title="Help">‚ùì</button>
            </div>
        </header>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Left Panel -->
            <div class="left-panel">
                <!-- Input Section -->
                <div class="section">
                <h2>üì• Input</h2>

                <!-- Tab Switcher -->
                <div class="tabs">
                    <button class="tab" onclick="switchTab('csv')">üìÅ CSV File</button>
                    <button class="tab active" onclick="switchTab('text')">üìÑ Text/Paste</button>
                </div>

                <!-- CSV Upload Tab -->
                <div id="csv-tab" class="tab-content">
                    <div class="upload-area" id="upload-area">
                        <input type="file" id="file-input" accept=".csv,.txt,.log,.json" style="display: none;">
                        <div class="upload-icon">üìÅ</div>
                        <p class="upload-text">Drop CSV file here or <span class="link" onclick="document.getElementById('file-input').click()">browse</span></p>
                        <p class="upload-hint">Supports .csv, .txt, .log files (max 50MB)</p>
                    </div>

                    <div class="form-group">
                        <label for="content-column">Content Column Name:</label>
                        <input type="text" id="content-column" value="Content" placeholder="Content">
                    </div>
                </div>

                <!-- Text Input Tab -->
                <div id="text-tab" class="tab-content active">
                    <textarea id="text-input" placeholder="Paste your logs here...

Example:
Received event id:&quot;123&quot; type:&quot;test&quot; data:{field:&quot;value&quot;}"></textarea>
                </div>
            </div>

                <!-- Parse Button -->
                <div class="section">
                    <button class="btn-primary" id="parse-btn" onclick="parseLog()">
                        üöÄ Parse Logs
                    </button>
                </div>

                <!-- Progress Bar -->
                <div id="progress-bar" class="progress-bar" style="display: none;">
                    <div class="progress-fill"></div>
                </div>

            <!-- Options Section (Collapsible) -->
            <div class="section collapsible-section">
                <div class="collapsible-header" onclick="toggleOptions()">
                    <div>
                        <h2>‚öôÔ∏è Options</h2>
                        <p class="collapsible-hint">Click to configure parsing options</p>
                    </div>
                    <span class="collapse-icon" id="options-icon">‚ñº</span>
                </div>
                <div class="collapsible-content" id="options-content" style="display: none;">
                <div class="options-grid">
                    <div class="option-item">
                        <label class="checkbox-label">
                            <input type="checkbox" id="decode-base64" checked>
                            <span>Decode Base64</span>
                        </label>
                        <p class="option-description">Decode base64 encoded fields (public keys, etc.)</p>
                    </div>

                    <div class="option-item">
                        <label class="checkbox-label">
                            <input type="checkbox" id="redact">
                            <span>Redact Sensitive Fields</span>
                        </label>
                        <p class="option-description">Hide keys, tokens, secrets (keeps first/last N chars)</p>
                    </div>

                    <div class="option-item">
                        <label class="checkbox-label">
                            <input type="checkbox" id="include-metadata" checked>
                            <span>Include Metadata</span>
                        </label>
                        <p class="option-description">Include CSV metadata (Date, Host, Service)</p>
                    </div>

                    <div class="option-item">
                        <label for="keep-chars">Keep Characters:</label>
                        <div class="slider-container">
                            <input type="range" id="keep-chars" min="2" max="10" value="4">
                            <span id="keep-chars-value">4</span>
                        </div>
                        <p class="option-description">Number of chars to keep when redacting</p>
                    </div>
                </div>
                </div>
            </div>
            </div>

            <!-- Right Panel -->
            <div class="right-panel">
                <!-- Placeholder -->
                <div id="right-panel-placeholder" class="right-panel-placeholder">
                    <div>
                        <div style="font-size: 3rem; margin-bottom: 15px;">üìä</div>
                        <p>Your parsed results will appear here</p>
                        <p style="font-size: 0.85rem; margin-top: 10px;">Upload a file or paste text, then click "Parse Logs"</p>
                    </div>
                </div>

                <!-- Results Section -->
            <div id="results-section" class="section" style="display: none;">
                <div class="results-header">
                    <h2>üìã Results</h2>
                    <div class="results-actions">
                        <span id="results-count" class="results-count"></span>
                        <select id="format-select" class="format-select">
                            <option value="pretty">Pretty JSON</option>
                            <option value="compact">Compact JSON</option>
                            <option value="array">JSON Array</option>
                        </select>
                        <button class="btn-secondary" onclick="downloadResults()">‚¨áÔ∏è Download</button>
                        <button class="btn-secondary" onclick="copyResults(event)">üìã Copy</button>
                    </div>
                </div>
                <div class="results-container">
                    <pre id="results-output"></pre>
                </div>
            </div>

                <!-- Error Section -->
                <div id="error-section" class="error-section" style="display: none;">
                    <div class="error-content">
                        <span class="error-icon">‚ö†Ô∏è</span>
                        <div class="error-message">
                            <strong>Error</strong>
                            <p id="error-text"></p>
                        </div>
                        <button class="btn-icon" onclick="closeError()">‚úï</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- History Sidebar -->
        <div id="history-sidebar" class="history-sidebar">
            <div class="history-header">
                <h2>üìú History</h2>
                <button class="btn-icon" onclick="toggleHistory(event)">‚úï</button>
            </div>

            <div class="history-controls">
                <input type="text" id="history-search" class="history-search" placeholder="Search history..." oninput="searchHistory()">

                <div class="history-filter-buttons">
                    <button class="filter-btn active" onclick="filterStarred(false)" data-filter="all">All</button>
                    <button class="filter-btn" onclick="filterStarred(true)" data-filter="starred">‚òÖ Starred</button>
                </div>

                <button class="btn-secondary" onclick="clearHistory()" style="width: 100%; margin-top: 10px;">
                    üóëÔ∏è Clear All
                </button>
            </div>

            <div id="history-list" class="history-list">
                <!-- History entries will be rendered here -->
            </div>

            <div id="history-empty" class="history-empty" style="display: none;">
                <div class="empty-icon">üì≠</div>
                <p>No history yet</p>
                <p class="empty-hint">Parse some logs to see them here</p>
            </div>
        </div>

        <!-- Footer -->
        <footer class="footer">
            <p>üìä Log Parser Utility v2.0.0 (Standalone) | No Server Required</p>
        </footer>
    </div>

    <script>
// ====== JAVASCRIPT - Client-Side Log Parser ======
// All parsing logic runs in your browser - no server needed!

// Global state
let currentLogs = null;
let currentTab = 'text';
let uploadedFile = null;

// History Manager
const HistoryManager = {
    storageKey: 'logParserHistory',
    maxEntries: 50,

    init() {
        try {
            const data = localStorage.getItem(this.storageKey);
            if (!data) {
                this.save({ entries: [], maxEntries: this.maxEntries });
            } else {
                const parsed = JSON.parse(data);
                if (!parsed.entries || !Array.isArray(parsed.entries)) {
                    this.save({ entries: [], maxEntries: this.maxEntries });
                }
            }
        } catch (e) {
            console.error('Failed to initialize history:', e);
            this.save({ entries: [], maxEntries: this.maxEntries });
        }
    },

    save(data) {
        try {
            localStorage.setItem(this.storageKey, JSON.stringify(data));
        } catch (e) {
            if (e.name === 'QuotaExceededError') {
                console.warn('Storage quota exceeded, pruning entries...');
                this.pruneOldEntries(true);
            } else {
                console.error('Failed to save history:', e);
            }
        }
    },

    load() {
        try {
            const data = localStorage.getItem(this.storageKey);
            return data ? JSON.parse(data) : { entries: [], maxEntries: this.maxEntries };
        } catch (e) {
            console.error('Failed to load history:', e);
            return { entries: [], maxEntries: this.maxEntries };
        }
    },

    saveEntry(logs, sourceType, sourceName, config) {
        try {
            const truncatedLogs = logs.length > 100 ? logs.slice(0, 100) : logs;

            const entry = {
                id: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                timestamp: Date.now(),
                sourceType: sourceType,
                sourceName: sourceName,
                configuration: config,
                entryCount: logs.length,
                logs: truncatedLogs,
                preview: this.generatePreview(logs),
                starred: false
            };

            const data = this.load();
            data.entries.unshift(entry);

            if (data.entries.length > this.maxEntries) {
                this.pruneOldEntries(false, data);
            }

            this.save(data);
            return entry;
        } catch (e) {
            console.error('Failed to save history entry:', e);
            return null;
        }
    },

    getHistory(filterStarred = false) {
        const data = this.load();
        let entries = data.entries || [];

        if (filterStarred) {
            entries = entries.filter(e => e.starred);
        }

        entries.sort((a, b) => {
            if (a.starred && !b.starred) return -1;
            if (!a.starred && b.starred) return 1;
            return b.timestamp - a.timestamp;
        });

        return entries;
    },

    getEntry(id) {
        const data = this.load();
        return data.entries.find(e => e.id === id);
    },

    deleteEntry(id) {
        const data = this.load();
        data.entries = data.entries.filter(e => e.id !== id);
        this.save(data);
    },

    clearAll(keepStarred = true) {
        const data = this.load();
        if (keepStarred) {
            data.entries = data.entries.filter(e => e.starred);
        } else {
            data.entries = [];
        }
        this.save(data);
    },

    toggleStar(id) {
        const data = this.load();
        const entry = data.entries.find(e => e.id === id);
        if (entry) {
            entry.starred = !entry.starred;
            this.save(data);
            return entry.starred;
        }
        return false;
    },

    pruneOldEntries(force = false, existingData = null) {
        const data = existingData || this.load();
        const nonStarred = data.entries.filter(e => !e.starred);
        const starred = data.entries.filter(e => e.starred);

        if (force) {
            const toKeep = Math.floor(nonStarred.length / 2);
            data.entries = [...starred, ...nonStarred.slice(0, toKeep)];
        } else {
            const maxNonStarred = this.maxEntries - starred.length;
            data.entries = [...starred, ...nonStarred.slice(0, maxNonStarred)];
        }

        this.save(data);
    },

    generatePreview(logs) {
        if (!logs || logs.length === 0) return 'No logs';
        const firstLog = JSON.stringify(logs[0]);
        return firstLog.length > 100 ? firstLog.substring(0, 100) + '...' : firstLog;
    }
};

// ====== PROTOBUF PARSER ======
class ProtobufTextParser {
    constructor(text) {
        this.text = text;
        this.pos = 0;
        this.length = text.length;
    }

    skipWhitespace() {
        while (this.pos < this.length && ' \t\n\r'.includes(this.text[this.pos])) {
            this.pos++;
        }
    }

    peek() {
        this.skipWhitespace();
        if (this.pos < this.length) {
            return this.text[this.pos];
        }
        return '';
    }

    consume(expected = null) {
        this.skipWhitespace();
        if (this.pos >= this.length) return '';
        const char = this.text[this.pos];
        if (expected && char !== expected) {
            throw new Error(`Expected '${expected}' but got '${char}' at position ${this.pos}`);
        }
        this.pos++;
        return char;
    }

    parseString() {
        this.consume('"');
        let start = this.pos;
        while (this.pos < this.length && this.text[this.pos] !== '"') {
            if (this.text[this.pos] === '\\') {
                this.pos += 2;
            } else {
                this.pos++;
            }
        }
        const result = this.text.substring(start, this.pos);
        this.consume('"');
        return result;
    }

    parseNumber() {
        const start = this.pos;
        if (this.text[this.pos] === '-') this.pos++;
        while (this.pos < this.length && /\d/.test(this.text[this.pos])) {
            this.pos++;
        }
        return parseInt(this.text.substring(start, this.pos));
    }

    parseBoolean() {
        if (this.text.substr(this.pos, 4) === 'true') {
            this.pos += 4;
            return true;
        } else if (this.text.substr(this.pos, 5) === 'false') {
            this.pos += 5;
            return false;
        }
        throw new Error(`Expected boolean at position ${this.pos}`);
    }

    parseIdentifier() {
        const start = this.pos;
        while (this.pos < this.length && /[a-zA-Z0-9_]/.test(this.text[this.pos])) {
            this.pos++;
        }
        return this.text.substring(start, this.pos);
    }

    parseValue() {
        const char = this.peek();
        if (char === '"') {
            return this.parseString();
        } else if (char === '{') {
            return this.parseMessage();
        } else if (/[\d-]/.test(char)) {
            return this.parseNumber();
        } else if (char === 't' || char === 'f') {
            return this.parseBoolean();
        }
        throw new Error(`Unexpected character '${char}' at position ${this.pos}`);
    }

    parseMessage() {
        const result = {};
        this.consume('{');

        while (this.peek() !== '}') {
            const fieldName = this.parseIdentifier();
            this.consume(':');
            const value = this.parseValue();

            if (fieldName in result) {
                if (!Array.isArray(result[fieldName])) {
                    result[fieldName] = [result[fieldName]];
                }
                result[fieldName].push(value);
            } else {
                result[fieldName] = value;
            }
        }

        this.consume('}');
        return result;
    }

    parse() {
        const match = this.text.match(/\b([a-zA-Z_][a-zA-Z0-9_]*):\s*["{0-9]/);
        if (match) {
            this.pos = match.index;
        }

        const result = {};

        while (this.pos < this.length) {
            this.skipWhitespace();
            if (this.pos >= this.length) break;

            const fieldName = this.parseIdentifier();
            if (!fieldName) break;

            this.consume(':');
            const value = this.parseValue();

            if (fieldName in result) {
                if (!Array.isArray(result[fieldName])) {
                    result[fieldName] = [result[fieldName]];
                }
                result[fieldName].push(value);
            } else {
                result[fieldName] = value;
            }
        }

        return result;
    }
}

// ====== PARSING FUNCTIONS ======
function redactSensitiveValue(value, keepChars = 4) {
    if (typeof value !== 'string') return value;
    if (value.length <= keepChars * 2) return value;
    return `${value.substring(0, keepChars)}...${value.substring(value.length - keepChars)}`;
}

function redactSensitiveFields(data, keysToRedact = null, keepChars = 4) {
    if (keysToRedact === null) {
        keysToRedact = ['public_key', 'private_key', 'secret', 'token', 'api_key',
                       'password', 'credential', 'auth', 'authorization'];
    }

    if (typeof data === 'object' && data !== null && !Array.isArray(data)) {
        const result = {};
        for (const [key, value] of Object.entries(data)) {
            const keyLower = key.toLowerCase();
            const shouldRedact = keysToRedact.some(sensitive => keyLower.includes(sensitive));

            if (shouldRedact && typeof value === 'string') {
                result[key] = redactSensitiveValue(value, keepChars);
                result[`${key}_redacted`] = true;
            } else if (typeof value === 'object') {
                result[key] = redactSensitiveFields(value, keysToRedact, keepChars);
            } else {
                result[key] = value;
            }
        }
        return result;
    } else if (Array.isArray(data)) {
        return data.map(item => redactSensitiveFields(item, keysToRedact, keepChars));
    }
    return data;
}

function decodeBase64Fields(data, keysToDecode = null) {
    if (keysToDecode === null) {
        keysToDecode = ['public_key'];
    }

    if (typeof data === 'object' && data !== null && !Array.isArray(data)) {
        const result = {};
        for (const [key, value] of Object.entries(data)) {
            if (keysToDecode.includes(key) && typeof value === 'string') {
                try {
                    const decoded = atob(value);
                    result[key] = decoded;
                    result[`${key}_base64`] = value;
                } catch (e) {
                    result[key] = value;
                }
            } else if (typeof value === 'object') {
                result[key] = decodeBase64Fields(value, keysToDecode);
            } else {
                result[key] = value;
            }
        }
        return result;
    } else if (Array.isArray(data)) {
        return data.map(item => decodeBase64Fields(item, keysToDecode));
    }
    return data;
}

function splitLogEntries(logText) {
    const patterns = [
        /(?=Received\s+\w+\s+event\s+)/g,
        /(?=Processing\s+.*?\s+metadata:\s+)/g,
        /(?=\n\s*[a-zA-Z_][a-zA-Z0-9_]*:)/g,
    ];

    let entries = [logText];

    for (const pattern of patterns) {
        const splitResult = logText.split(pattern).filter(entry => entry.trim());
        if (splitResult.length > entries.length) {
            entries = splitResult;
        }
    }

    return entries;
}

function parseDatadogLogs(logText, decodeBase64 = true, redact = false, keepChars = 4) {
    const stripped = logText.trim();

    // Try JSON parsing first
    if (stripped.startsWith('{') || stripped.startsWith('[')) {
        try {
            let jsonData = JSON.parse(stripped);
            if (!Array.isArray(jsonData)) {
                jsonData = [jsonData];
            }

            return jsonData.map(item => {
                if (decodeBase64) {
                    item = decodeBase64Fields(item);
                }
                if (redact) {
                    item = redactSensitiveFields(item, null, keepChars);
                }
                return item;
            });
        } catch (e) {
            // Not JSON, continue
        }
    }

    const entries = splitLogEntries(logText);
    const results = [];

    for (const entry of entries) {
        try {
            const entryStripped = entry.trim();
            if (entryStripped.startsWith('{')) {
                try {
                    let parsed = JSON.parse(entryStripped);
                    if (decodeBase64) {
                        parsed = decodeBase64Fields(parsed);
                    }
                    if (redact) {
                        parsed = redactSensitiveFields(parsed, null, keepChars);
                    }
                    results.push(parsed);
                    continue;
                } catch (e) {
                    // Not JSON, continue to protobuf parsing
                }
            }

            // Parse as protobuf
            const parser = new ProtobufTextParser(entry);
            let parsed = parser.parse();

            if (Object.keys(parsed).length === 0) {
                parsed = { message: entry, format: "plain_text" };
            } else {
                if (decodeBase64) {
                    parsed = decodeBase64Fields(parsed);
                }
                if (redact) {
                    parsed = redactSensitiveFields(parsed, null, keepChars);
                }
            }

            results.push(parsed);
        } catch (e) {
            console.error('Error parsing entry:', e);
            results.push({
                message: entry,
                format: "plain_text",
                parse_error: e.message
            });
        }
    }

    return results;
}

// ====== CSV PARSING ======
function parseCSV(text) {
    const lines = text.split('\n');
    if (lines.length === 0) return { headers: [], rows: [] };

    const headers = lines[0].split(',').map(h => h.trim().replace(/^"|"$/g, ''));
    const rows = [];

    for (let i = 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;

        const values = [];
        let current = '';
        let inQuotes = false;

        for (let j = 0; j < line.length; j++) {
            const char = line[j];
            if (char === '"') {
                inQuotes = !inQuotes;
            } else if (char === ',' && !inQuotes) {
                values.push(current.trim().replace(/^"|"$/g, ''));
                current = '';
            } else {
                current += char;
            }
        }
        values.push(current.trim().replace(/^"|"$/g, ''));

        if (values.length === headers.length) {
            const row = {};
            headers.forEach((header, idx) => {
                row[header] = values[idx];
            });
            rows.push(row);
        }
    }

    return { headers, rows };
}

function extractLogsFromCSV(csvText, contentColumn, includeMetadata, decodeBase64, redact, keepChars) {
    const { headers, rows } = parseCSV(csvText);

    if (!headers.includes(contentColumn)) {
        throw new Error(`Column '${contentColumn}' not found. Available: ${headers.join(', ')}`);
    }

    const results = [];
    for (const row of rows) {
        const content = (row[contentColumn] || '').trim();
        if (!content) continue;

        let parsedContent = parseDatadogLogs(content, decodeBase64, redact, keepChars);
        if (parsedContent.length === 1) {
            parsedContent = parsedContent[0];
        }

        if (includeMetadata) {
            const metadata = {};
            for (const [key, value] of Object.entries(row)) {
                if (key !== contentColumn) {
                    metadata[key] = value;
                }
            }
            results.push({ metadata, log: parsedContent });
        } else {
            results.push(parsedContent);
        }
    }

    return results;
}

// ====== UI FUNCTIONS ======
// Initialize app
document.addEventListener('DOMContentLoaded', function() {
    HistoryManager.init();
    initializeEventListeners();
    initializeDragAndDrop();
    initializeKeyboardShortcuts();
});

function initializeEventListeners() {
    document.getElementById('file-input').addEventListener('change', handleFileSelect);

    const keepCharsSlider = document.getElementById('keep-chars');
    const keepCharsValue = document.getElementById('keep-chars-value');
    keepCharsSlider.addEventListener('input', function() {
        keepCharsValue.textContent = this.value;
    });

    document.getElementById('format-select').addEventListener('change', function() {
        if (currentLogs) {
            displayResults(currentLogs, this.value);
        }
    });

    document.getElementById('redact').addEventListener('change', function() {
        document.getElementById('keep-chars').disabled = !this.checked;
    });
}

function initializeDragAndDrop() {
    const uploadArea = document.getElementById('upload-area');

    uploadArea.addEventListener('click', function() {
        document.getElementById('file-input').click();
    });

    uploadArea.addEventListener('dragover', function(e) {
        e.preventDefault();
        e.stopPropagation();
        this.classList.add('dragover');
    });

    uploadArea.addEventListener('dragleave', function(e) {
        e.preventDefault();
        e.stopPropagation();
        this.classList.remove('dragover');
    });

    uploadArea.addEventListener('drop', function(e) {
        e.preventDefault();
        e.stopPropagation();
        this.classList.remove('dragover');

        const files = e.dataTransfer.files;
        if (files.length > 0) {
            handleFile(files[0]);
        }
    });
}

function initializeKeyboardShortcuts() {
    document.addEventListener('keydown', function(e) {
        if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
            e.preventDefault();
            parseLog();
        }

        if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
            const resultsSection = document.getElementById('results-section');
            if (resultsSection.style.display !== 'none') {
                copyResults();
            }
        }

        if (e.key === 'Escape') {
            const sidebar = document.getElementById('history-sidebar');
            if (sidebar && sidebar.classList.contains('open')) {
                toggleHistory();
            }
        }
    });
}

function switchTab(tab) {
    currentTab = tab;

    const tabs = document.querySelectorAll('.tab');
    tabs.forEach(t => t.classList.remove('active'));
    event.target.classList.add('active');

    document.getElementById('csv-tab').classList.toggle('active', tab === 'csv');
    document.getElementById('text-tab').classList.toggle('active', tab === 'text');
}

function handleFileSelect(e) {
    const file = e.target.files[0];
    if (file) {
        handleFile(file);
    }
}

function handleFile(file) {
    uploadedFile = file;

    const uploadArea = document.getElementById('upload-area');
    uploadArea.innerHTML = `
        <div class="upload-icon">üìÑ</div>
        <p class="upload-text"><strong>${file.name}</strong></p>
        <p class="upload-hint">${formatFileSize(file.size)} | <span class="link" onclick="clearFile()">Remove</span></p>
    `;
}

function clearFile() {
    uploadedFile = null;
    document.getElementById('file-input').value = '';

    const uploadArea = document.getElementById('upload-area');
    uploadArea.innerHTML = `
        <div class="upload-icon">üìÅ</div>
        <p class="upload-text">Drop CSV file here or <span class="link" onclick="document.getElementById('file-input').click()">browse</span></p>
        <p class="upload-hint">Supports .csv, .txt, .log files (max 50MB)</p>
    `;
}

function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
}

async function parseLog() {
    hideError();
    hideResults();

    if (currentTab === 'csv' && !uploadedFile) {
        showError('Please select a CSV file to parse');
        return;
    }

    if (currentTab === 'text') {
        const text = document.getElementById('text-input').value.trim();
        if (!text) {
            showError('Please enter text to parse');
            return;
        }
    }

    showProgress();

    const parseBtn = document.getElementById('parse-btn');
    parseBtn.disabled = true;
    parseBtn.textContent = '‚è≥ Parsing...';

    try {
        let logs;
        let count;
        let stats = null;

        if (currentTab === 'csv') {
            const reader = new FileReader();
            await new Promise((resolve, reject) => {
                reader.onload = async function(e) {
                    try {
                        const csvText = e.target.result;
                        const contentColumn = document.getElementById('content-column').value;
                        const includeMetadata = document.getElementById('include-metadata').checked;
                        const decodeBase64 = document.getElementById('decode-base64').checked;
                        const redact = document.getElementById('redact').checked;
                        const keepChars = parseInt(document.getElementById('keep-chars').value);

                        logs = extractLogsFromCSV(csvText, contentColumn, includeMetadata, decodeBase64, redact, keepChars);
                        count = logs.length;

                        const { rows } = parseCSV(csvText);
                        stats = { total_rows: rows.length };

                        resolve();
                    } catch (error) {
                        reject(error);
                    }
                };
                reader.onerror = reject;
                reader.readAsText(uploadedFile);
            });
        } else {
            const text = document.getElementById('text-input').value;
            const decodeBase64 = document.getElementById('decode-base64').checked;
            const redact = document.getElementById('redact').checked;
            const keepChars = parseInt(document.getElementById('keep-chars').value);

            logs = parseDatadogLogs(text, decodeBase64, redact, keepChars);
            count = logs.length;
        }

        currentLogs = logs;
        displayResults(currentLogs, 'pretty');
        showResults(count, stats);

        // Save to history
        let sourceName;
        if (currentTab === 'csv') {
            sourceName = uploadedFile ? uploadedFile.name : 'CSV File';
        } else {
            const textContent = document.getElementById('text-input').value.trim();
            const firstLine = textContent.split('\n')[0];
            const preview = firstLine.length > 50 ? firstLine.substring(0, 50) + '...' : firstLine;
            sourceName = preview || 'Text Input';
        }
        const config = {
            decode_base64: document.getElementById('decode-base64').checked,
            redact: document.getElementById('redact').checked,
            keep_chars: parseInt(document.getElementById('keep-chars').value),
            include_metadata: currentTab === 'csv' ? document.getElementById('include-metadata').checked : false,
            content_column: currentTab === 'csv' ? document.getElementById('content-column').value : null
        };
        HistoryManager.saveEntry(logs, currentTab, sourceName, config);

    } catch (error) {
        console.error('Parse error:', error);
        showError(error.message || 'An unexpected error occurred');
    } finally {
        hideProgress();
        parseBtn.disabled = false;
        parseBtn.textContent = 'üöÄ Parse Logs';
    }
}

function displayResults(logs, format) {
    const output = document.getElementById('results-output');
    let content;

    switch (format) {
        case 'compact':
            content = logs.map(log => JSON.stringify(log)).join('\n');
            break;
        case 'array':
            content = JSON.stringify(logs, null, 2);
            break;
        default: // pretty
            content = logs.map(log => JSON.stringify(log, null, 2)).join('\n\n');
    }

    output.textContent = content;
    output.innerHTML = syntaxHighlight(content);
}

function syntaxHighlight(json) {
    json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function (match) {
        let cls = 'number';
        if (/^"/.test(match)) {
            if (/:$/.test(match)) {
                cls = 'key';
            } else {
                cls = 'string';
            }
        } else if (/true|false/.test(match)) {
            cls = 'boolean';
        } else if (/null/.test(match)) {
            cls = 'null';
        }
        return '<span class="' + cls + '">' + match + '</span>';
    });
}

function showResults(count, stats) {
    const resultsSection = document.getElementById('results-section');
    const resultsCount = document.getElementById('results-count');
    const placeholder = document.getElementById('right-panel-placeholder');

    let countText = `${count} log${count !== 1 ? 's' : ''} parsed`;
    if (stats) {
        countText += ` | ${stats.total_rows} total rows`;
    }

    resultsCount.textContent = countText;
    resultsSection.style.display = 'block';
    resultsSection.classList.add('fade-in');

    if (placeholder) {
        placeholder.classList.add('hidden');
    }
}

function hideResults() {
    const resultsSection = document.getElementById('results-section');
    const placeholder = document.getElementById('right-panel-placeholder');

    resultsSection.style.display = 'none';

    if (placeholder) {
        placeholder.classList.remove('hidden');
    }
}

function downloadResults() {
    if (!currentLogs) return;

    const format = document.getElementById('format-select').value;
    const filename = `parsed_logs_${new Date().getTime()}.json`;

    let content;
    if (format === 'compact') {
        content = currentLogs.map(log => JSON.stringify(log)).join('\n');
    } else if (format === 'array') {
        content = JSON.stringify(currentLogs, null, 2);
    } else {
        content = currentLogs.map(log => JSON.stringify(log, null, 2)).join('\n\n');
    }

    const blob = new Blob([content], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    URL.revokeObjectURL(url);
    document.body.removeChild(a);
}

function copyResults(event) {
    const output = document.getElementById('results-output');
    const text = output.textContent;

    navigator.clipboard.writeText(text).then(() => {
        const btn = event.target;
        const originalText = btn.textContent;
        btn.textContent = '‚úì Copied!';
        setTimeout(() => {
            btn.textContent = originalText;
        }, 2000);
    }).catch(err => {
        showError('Failed to copy: ' + err.message);
    });
}

function showError(message) {
    const errorSection = document.getElementById('error-section');
    const errorText = document.getElementById('error-text');

    errorText.textContent = message;
    errorSection.style.display = 'block';
    errorSection.classList.add('fade-in');

    errorSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
}

function hideError() {
    document.getElementById('error-section').style.display = 'none';
}

function closeError() {
    hideError();
}

function showProgress() {
    document.getElementById('progress-bar').style.display = 'block';
}

function hideProgress() {
    document.getElementById('progress-bar').style.display = 'none';
}

function showHelp() {
    alert('Log Parser Utility - Standalone Version\n\n' +
          '‚úÖ No server required - runs entirely in your browser\n' +
          '‚úÖ All data stays local - nothing sent to any server\n' +
          '‚úÖ Bookmark this page for easy access\n\n' +
          'Keyboard Shortcuts:\n' +
          '‚Ä¢ Ctrl/Cmd + Enter: Parse logs\n' +
          '‚Ä¢ Ctrl/Cmd + C: Copy results\n' +
          '‚Ä¢ Esc: Close panels\n\n' +
          'Features:\n' +
          '‚Ä¢ Parse Datadog protobuf logs\n' +
          '‚Ä¢ Extract logs from CSV files\n' +
          '‚Ä¢ Decode base64 fields\n' +
          '‚Ä¢ Redact sensitive data\n' +
          '‚Ä¢ Local history with starring');
}

function toggleOptions() {
    const content = document.getElementById('options-content');
    const icon = document.getElementById('options-icon');

    if (content.style.display === 'none') {
        content.style.display = 'block';
        icon.classList.add('expanded');
    } else {
        content.style.display = 'none';
        icon.classList.remove('expanded');
    }
}

// ====== HISTORY FUNCTIONS ======
let currentHistoryFilter = { starred: false, search: '' };

function toggleHistory(event) {
    if (event) {
        event.stopPropagation();
    }

    const sidebar = document.getElementById('history-sidebar');
    if (!sidebar) {
        console.error('History sidebar element not found!');
        return;
    }

    const isOpen = sidebar.classList.contains('open');

    if (isOpen) {
        sidebar.classList.remove('open');
    } else {
        sidebar.classList.add('open');
        renderHistoryList();
    }
}

function renderHistoryList(searchTerm = '', starredOnly = false) {
    const entries = HistoryManager.getHistory(starredOnly);
    const listContainer = document.getElementById('history-list');
    const emptyState = document.getElementById('history-empty');

    let filteredEntries = entries;
    if (searchTerm) {
        const search = searchTerm.toLowerCase();
        filteredEntries = entries.filter(e =>
            e.sourceName.toLowerCase().includes(search) ||
            e.preview.toLowerCase().includes(search) ||
            e.sourceType.toLowerCase().includes(search)
        );
    }

    if (filteredEntries.length === 0) {
        listContainer.style.display = 'none';
        emptyState.style.display = 'flex';
        return;
    }

    listContainer.style.display = 'block';
    emptyState.style.display = 'none';

    listContainer.innerHTML = filteredEntries.map((entry, index) => `
        <div class="history-entry ${entry.starred ? 'starred' : ''}" data-id="${entry.id}">
            <div class="history-entry-number">#${index + 1}</div>
            <div class="history-entry-content">
                <div class="history-entry-header">
                    <div class="history-header-left">
                        <span class="history-source-name">${entry.sourceName}</span>
                        <span class="source-type-badge ${entry.sourceType}">${entry.sourceType === 'csv' ? 'üìÅ CSV' : 'üìÑ Text'}</span>
                    </div>
                    <button class="star-button" onclick="toggleStarEntry('${entry.id}')" title="${entry.starred ? 'Unstar' : 'Star'}">
                        ${entry.starred ? '‚òÖ' : '‚òÜ'}
                    </button>
                </div>
                <div class="history-entry-meta">
                    <span class="history-entry-count">üìä ${entry.entryCount} log${entry.entryCount !== 1 ? 's' : ''}</span>
                    <span class="history-timestamp">üïí ${formatTimeAgo(entry.timestamp)}</span>
                </div>
                <div class="history-entry-actions">
                    <button class="btn-secondary btn-sm" onclick="restoreHistory('${entry.id}')">View</button>
                    <button class="btn-secondary btn-sm btn-delete" onclick="deleteHistoryEntry('${entry.id}')">Delete</button>
                </div>
            </div>
        </div>
    `).join('');
}

function restoreHistory(id) {
    const entry = HistoryManager.getEntry(id);
    if (!entry) {
        showError('History entry not found');
        return;
    }

    currentLogs = entry.logs;
    displayResults(currentLogs, 'pretty');
    showResults(entry.entryCount, null);
    toggleHistory();

    const resultsSection = document.getElementById('results-section');
    if (resultsSection) {
        resultsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
}

function deleteHistoryEntry(id) {
    const entry = HistoryManager.getEntry(id);
    if (!entry) return;

    const confirmMsg = entry.starred
        ? 'This is a starred entry. Are you sure you want to delete it?'
        : 'Are you sure you want to delete this entry?';

    if (confirm(confirmMsg)) {
        HistoryManager.deleteEntry(id);
        renderHistoryList(currentHistoryFilter.search, currentHistoryFilter.starred);
    }
}

function clearHistory() {
    const data = HistoryManager.load();
    const starredCount = data.entries.filter(e => e.starred).length;
    const totalCount = data.entries.length;

    if (totalCount === 0) {
        alert('History is already empty');
        return;
    }

    let keepStarred = true;

    if (starredCount > 0) {
        const choice = confirm(`Clear all ${totalCount} entries?\n\nClick OK to keep ${starredCount} starred entries, or Cancel to delete everything.`);
        if (choice) {
            keepStarred = true;
        } else {
            const confirmAll = confirm('Delete ALL entries including starred ones?');
            if (!confirmAll) return;
            keepStarred = false;
        }
    } else {
        if (!confirm(`Delete all ${totalCount} entries?`)) return;
        keepStarred = false;
    }

    HistoryManager.clearAll(keepStarred);
    renderHistoryList(currentHistoryFilter.search, currentHistoryFilter.starred);
}

function toggleStarEntry(id) {
    HistoryManager.toggleStar(id);
    renderHistoryList(currentHistoryFilter.search, currentHistoryFilter.starred);
}

function filterStarred(enabled) {
    currentHistoryFilter.starred = enabled;

    const buttons = document.querySelectorAll('.filter-btn');
    buttons.forEach(btn => {
        if (enabled && btn.dataset.filter === 'starred') {
            btn.classList.add('active');
        } else if (!enabled && btn.dataset.filter === 'all') {
            btn.classList.add('active');
        } else {
            btn.classList.remove('active');
        }
    });

    renderHistoryList(currentHistoryFilter.search, enabled);
}

function formatTimeAgo(timestamp) {
    const seconds = Math.floor((Date.now() - timestamp) / 1000);

    if (seconds < 60) return 'just now';
    if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
    if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
    if (seconds < 604800) return `${Math.floor(seconds / 86400)}d ago`;

    const date = new Date(timestamp);
    return date.toLocaleDateString();
}

function searchHistory() {
    const searchTerm = document.getElementById('history-search').value;
    currentHistoryFilter.search = searchTerm;
    renderHistoryList(searchTerm, currentHistoryFilter.starred);
}

// Click outside to close
window.onclick = function(event) {
    const sidebar = document.getElementById('history-sidebar');
    if (sidebar && sidebar.classList.contains('open') && !sidebar.contains(event.target)) {
        const historyBtn = event.target.closest('.btn-with-text') || event.target.closest('[onclick*="toggleHistory"]');
        if (!historyBtn) {
            toggleHistory();
        }
    }
}
    </script>
</body>
</html>
